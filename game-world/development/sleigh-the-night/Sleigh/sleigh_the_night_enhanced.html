<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SLEIGH THE NIGHT - Enhanced Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000; 
            overflow: hidden; 
            font-family: 'Courier New', monospace;
            color: #0ff;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background: linear-gradient(180deg, #001a33 0%, #000 100%);
            border: 2px solid #0ff;
            box-shadow: 0 0 20px #0ff;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            text-shadow: 0 0 10px #0ff;
            z-index: 10;
        }
        #ability-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .ability-btn {
            width: 50px;
            height: 50px;
            border: 2px solid #0ff;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 8px;
            color: #0ff;
            font-size: 10px;
            cursor: pointer;
            position: relative;
            text-shadow: 0 0 5px #0ff;
        }
        .ability-btn.active {
            background: rgba(0, 255, 255, 0.6);
            box-shadow: 0 0 15px #0ff;
        }
        .ability-btn .cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: rgba(255, 0, 0, 0.5);
            border-radius: 6px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 12px;
            text-align: right;
            opacity: 0.7;
        }
        #boss-hud {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        #boss-name {
            font-size: 20px;
            color: #f00;
            text-shadow: 0 0 10px #f00;
        }
        #boss-health {
            width: 400px;
            height: 20px;
            border: 2px solid #f00;
            background: #000;
        }
        #boss-health-bar {
            height: 100%;
            background: linear-gradient(90deg, #f00, #f80);
            transition: width 0.2s;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #0ff;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 30px #0ff;
        }
        .menu-btn {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            margin: 10px;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px #0ff;
            transition: all 0.3s;
        }
        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px #0ff;
        }
        h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #0ff;
        }
        .powerup-ui {
            position: absolute;
            top: 100px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .powerup-active {
            padding: 8px;
            border: 1px solid;
            background: rgba(0, 0, 0, 0.7);
            font-size: 12px;
            min-width: 150px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>
        
        <div id="hud">
            <div>HP: <span id="hp">100</span>/<span id="maxHp">100</span></div>
            <div>SCORE: <span id="score">0</span></div>
            <div>WAVE: <span id="wave">1</span></div>
            <div>LVL: <span id="level">1</span></div>
            <div id="synergy">SYNERGY: <span id="synergy-meter">0</span>%</div>
        </div>
        
        <div id="boss-hud">
            <div id="boss-name">BOSS</div>
            <div id="boss-health">
                <div id="boss-health-bar"></div>
            </div>
        </div>
        
        <div class="powerup-ui" id="powerup-ui"></div>
        
        <div id="ability-bar"></div>
        
        <div id="controls">
            <div>WASD / Arrows: Move</div>
            <div>Mouse: Aim & Shoot</div>
            <div>1-9 / E: Abilities</div>
            <div>Space: Dodge</div>
        </div>
        
        <div id="menu">
            <h1>SLEIGH THE NIGHT</h1>
            <p>Neo-Noir Christmas Action</p>
            <button class="menu-btn" onclick="startGame('story')">STORY MODE</button>
            <button class="menu-btn" onclick="startGame('endless')">ENDLESS MODE</button>
        </div>
    </div>

    <script>
// ============================================================================
// SLEIGH THE NIGHT - Enhanced Edition
// Neo-Noir Cyberpunk Christmas Twin-Stick Shooter
// ============================================================================

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width, height;

function resizeCanvas() {
    width = canvas.width = Math.min(window.innerWidth - 4, 1200);
    height = canvas.height = Math.min(window.innerHeight - 4, 800);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ============================================================================
// GAME STATE
// ============================================================================

const state = {
    mode: null,
    paused: false,
    gameOver: false,
    score: 0,
    wave: 1,
    level: 1,
    exp: 0,
    expToNext: 100,
    enemies: [],
    bullets: [],
    particles: [],
    powerups: [],
    activePowerups: [],
    hazards: [],
    damageTexts: [],
    boss: null,
    enemiesThisWave: 0,
    enemiesKilled: 0
};

// ============================================================================
// PLAYER
// ============================================================================

const player = {
    x: width/2,
    y: height/2,
    r: 20,
    speed: 250,
    hp: 100,
    maxHp: 100,
    c: '#0ff',
    angle: 0,
    fireRate: 0.15,
    fireCd: 0,
    abilityCd: 0,
    dodgeCd: 0,
    dodging: false,
    activeReindeer: 0,
    damageMultiplier: 1,
    speedMultiplier: 1,
    fireRateMultiplier: 1,
    shield: false,
    invincible: false,
    frozen: 0,
    onIce: false,
    synergyMeter: 0,
    synergyMax: 100,
    lastAbilities: []
};

// ============================================================================
// REINDEER ABILITIES
// ============================================================================

const REINDEER = [
    {n: 'Dasher', k: '1', cd: 3, c: '#0ff', act: () => {
        player.dodging = true;
        player.speedMultiplier = 3;
        setTimeout(() => {
            player.dodging = false;
            player.speedMultiplier = 1;
        }, 300);
    }},
    {n: 'Dancer', k: '2', cd: 8, c: '#f0f', act: () => {
        for (let i = 0; i < 16; i++) {
            const angle = (Math.PI * 2 / 16) * i;
            state.bullets.push({
                x: player.x, y: player.y,
                dx: Math.cos(angle), dy: Math.sin(angle),
                s: 400, dmg: 15, c: '#f0f'
            });
        }
    }},
    {n: 'Prancer', k: '3', cd: 10, c: '#0f0', act: () => {
        state.enemies.forEach(e => {
            if (dist(player, e) < 200) {
                e.hp *= 0.5;
                spawnDamageText(e.x, e.y, 'LEAPING!', '#0f0');
            }
        });
    }},
    {n: 'Vixen', k: '4', cd: 6, c: '#f00', act: () => {
        const circle = {x: player.x, y: player.y, r: 120, duration: 3, c: '#f00'};
        const interval = setInterval(() => {
            state.enemies.forEach(e => {
                if (dist(circle, e) < circle.r) {
                    takeDamage(e, 10);
                    e.burn = 3;
                }
            });
            circle.duration -= 0.1;
            if (circle.duration <= 0) clearInterval(interval);
        }, 100);
    }},
    {n: 'Comet', k: '5', cd: 4, c: '#ff0', act: () => {
        for (let i = 0; i < 5; i++) {
            setTimeout(() => {
                const angle = Math.atan2(input.mouseY - player.y, input.mouseX - player.x) + (Math.random() - 0.5) * 0.3;
                state.bullets.push({
                    x: player.x, y: player.y,
                    dx: Math.cos(angle), dy: Math.sin(angle),
                    s: 600, dmg: 25, c: '#ff0'
                });
            }, i * 100);
        }
    }},
    {n: 'Cupid', k: '6', cd: 12, c: '#f08', act: () => {
        player.hp = Math.min(player.maxHp, player.hp + 50);
        spawnDamageText(player.x, player.y, '+50 HP', '#0f0');
    }},
    {n: 'Donner', k: '7', cd: 10, c: '#80f', act: () => {
        state.enemies.forEach(e => {
            if (dist(player, e) < 200) {
                takeDamage(e, 40);
                e.stun = 2;
            }
        });
        spawnParticles(player.x, player.y, '#80f', 30);
    }},
    {n: 'Blitzen', k: '8', cd: 8, c: '#ff0', act: () => {
        const target = state.enemies.reduce((nearest, e) => 
            !nearest || dist(player, e) < dist(player, nearest) ? e : nearest, null);
        if (target) {
            state.bullets.push({
                x: player.x, y: player.y,
                tx: target, s: 800, dmg: 80, c: '#ff0', chain: 3
            });
        }
    }},
    {n: 'Rudolph', k: '9', cd: 15, c: '#f00', act: () => {
        const beam = {x: player.x, y: player.y, angle: player.angle, duration: 2};
        const interval = setInterval(() => {
            state.enemies.forEach(e => {
                const dx = e.x - beam.x;
                const dy = e.y - beam.y;
                const angleToEnemy = Math.atan2(dy, dx);
                const diff = Math.abs(angleToEnemy - beam.angle);
                if (diff < 0.2 && Math.hypot(dx, dy) < 500) {
                    takeDamage(e, 15);
                }
            });
            beam.duration -= 0.1;
            if (beam.duration <= 0) clearInterval(interval);
        }, 100);
    }}
];

// ============================================================================
// ENEMY TYPES (ENHANCED)
// ============================================================================

const ENEMY_TYPES = {
    grunt: { hp: 30, speed: 60, r: 15, c: '#f00', type: 'grunt', damage: 10 },
    brute: { hp: 80, speed: 40, r: 20, c: '#a0f', type: 'brute', damage: 15 },
    fast: { hp: 40, speed: 100, r: 12, c: '#ff0', type: 'fast', damage: 8 },
    // NEW ENEMY TYPES
    krampus: { hp: 50, speed: 80, r: 16, c: '#c00', type: 'krampus', damage: 15 },
    snatcher: { hp: 25, speed: 120, r: 10, c: '#0a0', type: 'snatcher', canSteal: true, damage: 5 },
    sniper: { hp: 35, speed: 0, r: 12, c: '#08f', type: 'sniper', range: 600, fireRate: 2, damage: 25 },
    golem: { hp: 150, speed: 30, r: 30, c: '#0ff', type: 'golem', freezeOnHit: true, damage: 20 },
    elf: { hp: 40, speed: 90, r: 13, c: '#0f0', type: 'elf', damage: 12 }
};

// ============================================================================
// POWER-UP SYSTEM
// ============================================================================

const POWERUP_TYPES = {
    naughty: { 
        name: 'Naughty List', 
        duration: 10, 
        c: '#f00',
        effect: (p) => { p.damageMultiplier = 2; }
    },
    gift: { 
        name: 'Gift of Giving', 
        duration: 8, 
        c: '#0ff',
        effect: (p) => { p.shield = true; }
    },
    spirit: { 
        name: 'Christmas Spirit', 
        duration: 12, 
        c: '#ff0',
        effect: (p) => { 
            p.speedMultiplier = 1.5; 
            p.fireRateMultiplier = 2;
        }
    },
    sleigh: { 
        name: 'Sleigh Ride', 
        duration: 5, 
        c: '#f0f',
        effect: (p) => { 
            p.invincible = true;
        }
    }
};

// ============================================================================
// INPUT HANDLING
// ============================================================================

const input = {
    keys: {},
    mouseX: width/2,
    mouseY: height/2,
    mouseDown: false
};

window.addEventListener('keydown', e => input.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    input.mouseX = e.clientX - rect.left;
    input.mouseY = e.clientY - rect.top;
});
window.addEventListener('mousedown', () => input.mouseDown = true);
window.addEventListener('mouseup', () => input.mouseDown = false);

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function rand(min, max) {
    return Math.random() * (max - min) + min;
}

function dist(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}

function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        state.particles.push({
            x, y,
            dx: (Math.random() - 0.5) * 200,
            dy: (Math.random() - 0.5) * 200,
            life: 0.5,
            c: color
        });
    }
}

function spawnDamageText(x, y, text, color) {
    state.damageTexts.push({
        x, y: y - 20,
        text, c: color,
        life: 1
    });
}

// ============================================================================
// GAME LOGIC
// ============================================================================

function takeDamage(ent, amt) {
    const finalDamage = amt * (ent === player ? 1 : player.damageMultiplier);
    ent.hp -= finalDamage;
    spawnDamageText(ent.x, ent.y, Math.floor(finalDamage), '#fff');
    
    if (ent !== player) {
        player.synergyMeter = Math.min(player.synergyMax, player.synergyMeter + finalDamage * 0.5);
    }
    
    if(ent.hp <= 0 && ent !== player) {
        state.score += (ent.maxHp || 30);
        state.exp += 20;
        state.enemiesKilled++;
        if(state.exp >= state.expToNext) levelUp();
        spawnParticles(ent.x, ent.y, ent.c, 15);
        
        // Power-up drop chance (10%)
        if (Math.random() < 0.1) {
            spawnPowerup(ent.x, ent.y);
        }
    }
}

function hitPlayer(damage) {
    if (player.invincible || player.dodging) return;
    if (player.shield) {
        player.shield = false;
        state.activePowerups = state.activePowerups.filter(p => p.type !== 'gift');
        spawnDamageText(player.x, player.y, 'SHIELD BLOCKED!', '#0ff');
        return;
    }
    takeDamage(player, damage);
    spawnParticles(player.x, player.y, '#f00', 10);
    if (player.hp <= 0) gameOver();
}

function levelUp() {
    state.level++;
    state.exp = 0;
    state.expToNext = Math.floor(state.expToNext * 1.2);
    player.maxHp += 20;
    player.hp = player.maxHp;
    spawnDamageText(player.x, player.y, 'LEVEL UP!', '#0f0');
}

function spawnEnemy() {
    const edge = Math.floor(Math.random()*4);
    let x, y;
    if(edge === 0) { x = rand(0, width); y = -20; }
    else if(edge === 1) { x = width+20; y = rand(0, height); }
    else if(edge === 2) { x = rand(0, width); y = height+20; }
    else { x = -20; y = rand(0, height); }
    
    // Enhanced enemy type selection based on wave
    const roll = Math.random();
    let enemyType;
    
    if (state.wave < 3) {
        if(roll > 0.7) enemyType = 'brute';
        else if(roll > 0.4) enemyType = 'fast';
        else enemyType = 'grunt';
    } else if (state.wave < 6) {
        if(roll > 0.85) enemyType = 'krampus';
        else if(roll > 0.7) enemyType = 'snatcher';
        else if(roll > 0.5) enemyType = 'brute';
        else if(roll > 0.3) enemyType = 'fast';
        else enemyType = 'grunt';
    } else {
        if(roll > 0.92) enemyType = 'golem';
        if(roll > 0.84) enemyType = 'elf';
        else if(roll > 0.76) enemyType = 'sniper';
        else if(roll > 0.68) enemyType = 'krampus';
        else if(roll > 0.56) enemyType = 'snatcher';
        else if(roll > 0.36) enemyType = 'brute';
        else if(roll > 0.18) enemyType = 'fast';
        else enemyType = 'grunt';
    }
    
    const stats = {...ENEMY_TYPES[enemyType]};
    stats.hp += state.level * 10;
    stats.maxHp = stats.hp;
    
    state.enemies.push({ x, y, ...stats, lastFire: 0, stun: 0, burn: 0 });
}

function spawnPowerup(x, y) {
    const types = Object.keys(POWERUP_TYPES);
    const type = types[Math.floor(Math.random() * types.length)];
    const powerup = { 
        x, y, 
        type, 
        r: 15, 
        c: POWERUP_TYPES[type].c,
        lifetime: 10
    };
    state.powerups.push(powerup);
}

function activatePowerup(type) {
    const powerup = POWERUP_TYPES[type];
    powerup.effect(player);
    state.activePowerups.push({
        type,
        remaining: powerup.duration
    });
    updatePowerupUI();
}

function deactivatePowerup(type) {
    if (type === 'naughty') player.damageMultiplier = 1;
    if (type === 'gift') player.shield = false;
    if (type === 'spirit') {
        player.speedMultiplier = 1;
        player.fireRateMultiplier = 1;
    }
    if (type === 'sleigh') player.invincible = false;
    updatePowerupUI();
}

function updatePowerupUI() {
    const ui = document.getElementById('powerup-ui');
    ui.innerHTML = '';
    state.activePowerups.forEach(ap => {
        const div = document.createElement('div');
        div.className = 'powerup-active';
        div.style.borderColor = POWERUP_TYPES[ap.type].c;
        div.innerHTML = `${POWERUP_TYPES[ap.type].name}<br>${ap.remaining.toFixed(1)}s`;
        ui.appendChild(div);
    });
}

function spawnHazards() {
    // Icy patches
    for (let i = 0; i < 5; i++) {
        state.hazards.push({
            type: 'ice',
            x: rand(100, width - 100),
            y: rand(100, height - 100),
            r: 60,
            c: '#0ff'
        });
    }
    
    // Christmas light traps
    for (let i = 0; i < 3; i++) {
        state.hazards.push({
            type: 'lights',
            x: rand(100, width - 100),
            y: rand(100, height - 100),
            r: 40,
            c: '#ff0',
            active: false,
            timer: 0,
            interval: 3
        });
    }
}

function triggerAbility(index) {
    if(player.abilityCd > 0) return;
    
    player.activeReindeer = index;
    const reindeer = REINDEER[index];
    player.abilityCd = reindeer.cd;
    
    player.lastAbilities.push(reindeer.n.toLowerCase());
    if (player.lastAbilities.length > 2) player.lastAbilities.shift();
    
    reindeer.act();
    spawnDamageText(player.x, player.y - 40, reindeer.n, reindeer.c);
}

// ============================================================================
// UPDATE LOGIC
// ============================================================================

function update(dt) {
    if (state.paused || state.gameOver) return;
    
    // Player input
    let dx = 0, dy = 0;
    if (input.keys['w'] || input.keys['arrowup']) dy -= 1;
    if (input.keys['s'] || input.keys['arrowdown']) dy += 1;
    if (input.keys['a'] || input.keys['arrowleft']) dx -= 1;
    if (input.keys['d'] || input.keys['arrowright']) dx += 1;
    
    // Movement
    const speed = player.speed * player.speedMultiplier * (player.onIce ? 0.5 : 1) * (player.frozen > 0 ? 0 : 1);
    player.onIce = false; // Reset each frame
    
    if (dx || dy) {
        const mag = Math.hypot(dx, dy);
        player.x += (dx/mag) * speed * dt;
        player.y += (dy/mag) * speed * dt;
        player.x = Math.max(player.r, Math.min(width - player.r, player.x));
        player.y = Math.max(player.r, Math.min(height - player.r, player.y));
    }
    
    // Player angle
    player.angle = Math.atan2(input.mouseY - player.y, input.mouseX - player.x);
    
    // Auto-fire
    player.fireCd -= dt;
    if (input.mouseDown && player.fireCd <= 0) {
        player.fireCd = player.fireRate / player.fireRateMultiplier;
        state.bullets.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(player.angle),
            dy: Math.sin(player.angle),
            s: 500,
            dmg: 10,
            c: '#0ff'
        });
    }
    
    // Abilities
    player.abilityCd = Math.max(0, player.abilityCd - dt);
    player.dodgeCd = Math.max(0, player.dodgeCd - dt);
    player.frozen = Math.max(0, player.frozen - dt);
    
    // Ability hotkeys
    REINDEER.forEach((r, i) => {
        if (input.keys[r.k] || input.keys['e']) {
            triggerAbility(i);
        }
    });
    
    // Dodge
    if ((input.keys[' '] || input.keys['space']) && player.dodgeCd === 0) {
        player.dodgeCd = 2;
        player.dodging = true;
        setTimeout(() => player.dodging = false, 200);
    }
    
    // Update bullets
    state.bullets.forEach(b => {
        if (b.tx) {
            // Homing
            const angle = Math.atan2(b.tx.y - b.y, b.tx.x - b.x);
            b.dx = Math.cos(angle);
            b.dy = Math.sin(angle);
        }
        b.x += b.dx * b.s * dt;
        b.y += b.dy * b.s * dt;
    });
    
    // Bullet collision
    state.bullets = state.bullets.filter(b => {
        for (let e of state.enemies) {
            if (dist(b, e) < e.r) {
                takeDamage(e, b.dmg);
                return false;
            }
        }
        return b.x > -50 && b.x < width + 50 && b.y > -50 && b.y < height + 50;
    });
    
    // Update enemies
    state.enemies.forEach(e => {
        if (e.stun > 0) {
            e.stun -= dt;
            return;
        }
        
        if (e.burn > 0) {
            e.burn -= dt;
            if (Math.random() < 0.1) takeDamage(e, 2);
        }
        
        const angle = Math.atan2(player.y - e.y, player.x - e.x);
        
        if (e.type === 'sniper' && e.lastFire !== undefined) {
            e.lastFire += dt;
            if (e.lastFire > e.fireRate) {
                e.lastFire = 0;
                const d = dist(player, e);
                if (d < e.range) {
                    state.bullets.push({
                        x: e.x, y: e.y,
                        dx: Math.cos(angle), dy: Math.sin(angle),
                        s: 400, dmg: e.damage || 25, c: '#f80',
                        isEnemy: true
                    });
                }
            }
        } else if (e.type === 'snatcher' && e.canSteal) {
            let target = null;
            let minDist = 999;
            state.powerups?.forEach(p => {
                const d = dist(p, e);
                if (d < minDist) { minDist = d; target = p; }
            });
            
            if (target && minDist < 50) {
                state.powerups = state.powerups.filter(p => p !== target);
                spawnDamageText(e.x, e.y, 'STOLEN!', '#f00');
            } else {
                e.x += Math.cos(angle) * e.speed * dt;
                e.y += Math.sin(angle) * e.speed * dt;
            }
        } else {
            e.x += Math.cos(angle) * e.speed * dt;
            e.y += Math.sin(angle) * e.speed * dt;
        }
        
        // Hit player
        if(dist(player, e) < player.r + e.r) {
            hitPlayer(e.damage || 10);
            
            if (e.type === 'golem' && e.freezeOnHit) {
                player.frozen = 2.0;
                spawnDamageText(player.x, player.y, 'FROZEN!', '#0ff');
            }
        }
    });
    
    // Enemy bullets
    state.bullets.filter(b => b.isEnemy).forEach(b => {
        if (dist(player, b) < player.r) {
            hitPlayer(b.dmg);
            state.bullets = state.bullets.filter(x => x !== b);
        }
    });
    
    state.enemies = state.enemies.filter(e => e.hp > 0);
    
    // Update powerups
    for (let i = state.powerups.length - 1; i >= 0; i--) {
        const p = state.powerups[i];
        p.lifetime -= dt;
        
        if (dist(player, p) < player.r + p.r) {
            activatePowerup(p.type);
            state.powerups.splice(i, 1);
            spawnDamageText(player.x, player.y, POWERUP_TYPES[p.type].name, p.c);
        } else if (p.lifetime <= 0) {
            state.powerups.splice(i, 1);
        }
    }
    
    // Update active powerups
    for (let i = state.activePowerups.length - 1; i >= 0; i--) {
        const ap = state.activePowerups[i];
        ap.remaining -= dt;
        
        if (ap.remaining <= 0) {
            deactivatePowerup(ap.type);
            state.activePowerups.splice(i, 1);
        }
    }
    
    // Update hazards
    state.hazards.forEach(h => {
        if (h.type === 'ice') {
            if (dist(player, h) < h.r) {
                player.onIce = true;
            }
        } else if (h.type === 'lights') {
            h.timer += dt;
            if (h.timer > h.interval) {
                h.active = !h.active;
                h.timer = 0;
            }
            
            if (h.active && dist(player, h) < h.r) {
                hitPlayer(5);
            }
        }
    });
    
    // Falling icicles
    if (Math.random() < 0.01) {
        state.hazards.push({
            type: 'icicle',
            x: rand(0, width),
            y: -20,
            vy: 300,
            r: 8,
            c: '#0ff'
        });
    }
    
    state.hazards = state.hazards.filter(h => {
        if (h.type === 'icicle') {
            h.y += h.vy * dt;
            
            if (dist(player, h) < player.r + h.r) {
                hitPlayer(15);
                return false;
            }
            
            return h.y < height;
        }
        return true;
    });
    
    // Update particles
    state.particles.forEach(p => {
        p.x += p.dx * dt;
        p.y += p.dy * dt;
        p.life -= dt;
    });
    state.particles = state.particles.filter(p => p.life > 0);
    
    // Update damage texts
    state.damageTexts.forEach(t => {
        t.y -= 50 * dt;
        t.life -= dt;
    });
    state.damageTexts = state.damageTexts.filter(t => t.life > 0);
    
    // Wave management
    if (state.enemies.length === 0 && state.enemiesKilled >= state.enemiesThisWave) {
        nextWave();
    }
    
    // Enemy spawning
    if (state.enemies.length < 5 + state.wave * 2 && state.enemiesKilled < state.enemiesThisWave) {
        if (Math.random() < 0.02) spawnEnemy();
    }
    
    // Update HUD
    document.getElementById('hp').textContent = Math.max(0, Math.floor(player.hp));
    document.getElementById('maxHp').textContent = player.maxHp;
    document.getElementById('score').textContent = state.score;
    document.getElementById('wave').textContent = state.wave;
    document.getElementById('level').textContent = state.level;
    document.getElementById('synergy-meter').textContent = Math.floor((player.synergyMeter/player.synergyMax)*100);
    
    updatePowerupUI();
}

function nextWave() {
    state.wave++;
    state.enemiesThisWave = 10 + state.wave * 5;
    state.enemiesKilled = 0;
    spawnDamageText(width/2, height/2, `WAVE ${state.wave}`, '#0ff');
    
    // Re-spawn hazards
    if (state.wave % 3 === 0) {
        state.hazards = [];
        spawnHazards();
    }
}

// ============================================================================
// RENDER
// ============================================================================

function render() {
    ctx.fillStyle = '#001a33';
    ctx.fillRect(0, 0, width, height);
    
    // Hazards
    state.hazards.forEach(h => {
        ctx.save();
        if (h.type === 'ice') {
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.arc(h.x, h.y, h.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#0ff';
            ctx.stroke();
        } else if (h.type === 'lights') {
            ctx.fillStyle = h.active ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 255, 0, 0.1)';
            ctx.beginPath();
            ctx.arc(h.x, h.y, h.r, 0, Math.PI * 2);
            ctx.fill();
        } else if (h.type === 'icicle') {
            ctx.fillStyle = h.c;
            ctx.beginPath();
            ctx.moveTo(h.x, h.y);
            ctx.lineTo(h.x - 5, h.y - 15);
            ctx.lineTo(h.x + 5, h.y - 15);
            ctx.fill();
        }
        ctx.restore();
    });
    
    // Powerups
    state.powerups.forEach(p => {
        ctx.save();
        ctx.fillStyle = p.c;
        ctx.shadowColor = p.c;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
    
    // Enemies
    state.enemies.forEach(e => {
        ctx.save();
        ctx.fillStyle = e.c;
        if (e.stun > 0) ctx.fillStyle = '#fff';
        if (e.burn > 0) ctx.fillStyle = '#f80';
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
        ctx.fill();
        
        // HP bar
        if (e.hp < e.maxHp) {
            ctx.fillStyle = '#f00';
            ctx.fillRect(e.x - e.r, e.y - e.r - 10, e.r * 2, 4);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(e.x - e.r, e.y - e.r - 10, e.r * 2 * (e.hp / e.maxHp), 4);
        }
        ctx.restore();
    });
    
    // Bullets
    state.bullets.forEach(b => {
        ctx.fillStyle = b.c;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // Player
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    if (player.invincible) {
        ctx.shadowColor = '#f0f';
        ctx.shadowBlur = 20;
    }
    if (player.dodging) {
        ctx.globalAlpha = 0.5;
    }
    ctx.fillStyle = player.c;
    ctx.beginPath();
    ctx.arc(0, 0, player.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(player.r/2, 0, player.r/3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    
    // Particles
    state.particles.forEach(p => {
        ctx.fillStyle = p.c;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    });
    
    // Damage texts
    state.damageTexts.forEach(t => {
        ctx.fillStyle = t.c;
        ctx.font = 'bold 16px monospace';
        ctx.textAlign = 'center';
        ctx.globalAlpha = t.life;
        ctx.fillText(t.text, t.x, t.y);
        ctx.globalAlpha = 1;
    });
}

// ============================================================================
// GAME FLOW
// ============================================================================

function startGame(mode) {
    state.mode = mode;
    state.paused = false;
    state.gameOver = false;
    state.score = 0;
    state.wave = 1;
    state.level = 1;
    state.exp = 0;
    state.enemiesThisWave = 10;
    state.enemiesKilled = 0;
    player.hp = player.maxHp;
    player.x = width/2;
    player.y = height/2;
    
    state.enemies = [];
    state.bullets = [];
    state.particles = [];
    state.powerups = [];
    state.activePowerups = [];
    state.hazards = [];
    
    spawnHazards();
    
    document.getElementById('menu').style.display = 'none';
    initAbilityBar();
    gameLoop();
}

function gameOver() {
    state.gameOver = true;
    alert(`GAME OVER!\nFinal Score: ${state.score}\nWaves Survived: ${state.wave}`);
    document.getElementById('menu').style.display = 'block';
}

function initAbilityBar() {
    const bar = document.getElementById('ability-bar');
    bar.innerHTML = '';
    REINDEER.forEach((r, i) => {
        const btn = document.createElement('div');
        btn.className = 'ability-btn';
        btn.textContent = `${r.k}\n${r.n}`;
        btn.onclick = () => triggerAbility(i);
        bar.appendChild(btn);
    });
}

// ============================================================================
// GAME LOOP
// ============================================================================

let lastTime = performance.now();

function gameLoop() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    
    update(dt);
    render();
    
    if (!state.gameOver) {
        requestAnimationFrame(gameLoop);
    }
}

console.log('%cSLEIGH THE NIGHT - Enhanced Edition', 'font-size: 20px; color: #0ff; font-weight: bold;');
console.log('%cNeo-Noir Christmas Action', 'font-size: 14px; color: #0ff;');

    </script>
</body>
</html>
