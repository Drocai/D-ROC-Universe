#!/usr/bin/env python3
â€œâ€â€
AutoMagic (O.T.T.O.) - Autonomous Content Creation System
Complete Production Implementation

A fully automated AI-driven system for generating, assembling and publishing
surreal, affirmation-style short-form video content across multiple platforms.
â€œâ€â€

import os
import sys
import time
import json
import base64
import logging
import argparse
import random
import schedule
import requests
import numpy as np
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
import hashlib

# Core libraries

from dotenv import load_dotenv
from PIL import Image, ImageDraw, ImageFont, ImageEnhance
import cv2

# AI APIs

try:
import openai
HAS_OPENAI = True
except ImportError:
HAS_OPENAI = False
logging.warning(â€œOpenAI not available - DALL-E features disabledâ€)

try:
import elevenlabs
HAS_ELEVENLABS = True
except ImportError:
HAS_ELEVENLABS = False
logging.warning(â€œElevenLabs not available - TTS features disabledâ€)

try:
import google.generativeai as genai
HAS_GEMINI = True
except ImportError:
HAS_GEMINI = False
logging.warning(â€œGoogle Generative AI not available - Gemini features disabledâ€)

# Video processing

try:
from moviepy.editor import (
VideoFileClip, ImageClip, AudioFileClip, TextClip,
CompositeAudioClip, CompositeVideoClip, concatenate_videoclips,
vfx, afx, ColorClip
)
HAS_MOVIEPY = True
except ImportError:
HAS_MOVIEPY = False
logging.error(â€œMoviePy not available - Video processing disabledâ€)

# Google APIs

try:
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload
HAS_GOOGLE_APIS = True
except ImportError:
HAS_GOOGLE_APIS = False
logging.warning(â€œGoogle APIs not available - YouTube features disabledâ€)

# Web scraping

try:
from bs4 import BeautifulSoup
HAS_BS4 = True
except ImportError:
HAS_BS4 = False
logging.warning(â€œBeautifulSoup not available - Web scraping features limitedâ€)

# === CONFIGURATION SYSTEM ===

class AutoMagicConfig:
â€œâ€â€œCentralized configuration management with validationâ€â€â€

```
def __init__(self):
    self.config = {}
    self.missing_apis = []
    self.load_environment()
    self.validate_config()
    self.setup_apis()

def load_environment(self):
    """Load and process environment variables"""
    load_dotenv()
    
    # Core settings
    self.config = {
        # API Keys
        "openai_api_key": os.getenv("OPENAI_API_KEY"),
        "elevenlabs_api_key": os.getenv("ELEVENLABS_API_KEY"),
        "elevenlabs_voice_id": os.getenv("ELEVENLABS_VOICE_ID"),
        "google_api_key": os.getenv("GOOGLE_API_KEY"),
        "google_cloud_project": os.getenv("GOOGLE_CLOUD_PROJECT"),
        "youtube_client_id": os.getenv("YOUTUBE_CLIENT_ID"),
        "youtube_client_secret": os.getenv("YOUTUBE_CLIENT_SECRET"),
        "youtube_channel_id": os.getenv("YOUTUBE_CHANNEL_ID"),
        "kling_api_key": os.getenv("KLING_API_KEY"),
        "kling_api_endpoint": os.getenv("KLING_API_ENDPOINT"),
        "comfyui_api_address": os.getenv("COMFYUI_API_ADDRESS", "http://127.0.0.1:8188"),
        "tiktok_session_id": os.getenv("TIKTOK_SESSION_ID"),
        
        # System Settings
        "daily_run_time": os.getenv("DAILY_RUN_TIME", "09:00"),
        "max_video_duration": int(os.getenv("MAX_VIDEO_DURATION", 60)),
        "cleanup_temp_files": os.getenv("CLEANUP_TEMP_FILES", "false").lower() == "true",
        "season": int(os.getenv("SEASON", 1)),
        "day_number": int(os.getenv("DAY_NUMBER", 1)),
        "content_style": os.getenv("CONTENT_STYLE", "glitchcore"),
        "viral_intensity": float(os.getenv("VIRAL_INTENSITY", 0.8)),
        
        # Paths
        "log_file_path": os.getenv("LOG_FILE_PATH", "logs/automagic.log"),
        "image_save_path": os.getenv("IMAGE_SAVE_PATH", "generated_images/"),
        "audio_save_path": os.getenv("AUDIO_SAVE_PATH", "generated_audio/"),
        "video_clip_save_path": os.getenv("VIDEO_CLIP_SAVE_PATH", "generated_video_clips/"),
        "final_video_save_path": os.getenv("FINAL_VIDEO_SAVE_PATH", "final_videos/"),
        
        # Content themes by season
        "content_themes": {
            1: "Everyday Absurdity",
            2: "Surreal Self-Care", 
            3: "Existential Encouragement"
        }
    }
    
    # Ensure paths end with /
    for key in ["image_save_path", "audio_save_path", "video_clip_save_path", "final_video_save_path"]:
        if self.config[key] and not self.config[key].endswith('/'):
            self.config[key] += '/'

def validate_config(self):
    """Validate configuration and create necessary directories"""
    # Create required directories
    dirs_to_create = [
        os.path.dirname(self.config["log_file_path"]),
        self.config["image_save_path"],
        self.config["audio_save_path"], 
        self.config["video_clip_save_path"],
        self.config["final_video_save_path"],
        "assets/sounds"
    ]
    
    for directory in dirs_to_create:
        if directory:
            os.makedirs(directory, exist_ok=True)

def setup_apis(self):
    """Initialize API clients"""
    # OpenAI
    if self.config["openai_api_key"] and HAS_OPENAI:
        openai.api_key = self.config["openai_api_key"]
    elif not self.config["openai_api_key"]:
        self.missing_apis.append("OpenAI API Key")
    
    # ElevenLabs
    if self.config["elevenlabs_api_key"] and HAS_ELEVENLABS:
        elevenlabs.set_api_key(self.config["elevenlabs_api_key"])
    elif not self.config["elevenlabs_api_key"]:
        self.missing_apis.append("ElevenLabs API Key")
    
    # Google Generative AI
    if self.config["google_api_key"] and HAS_GEMINI:
        genai.configure(api_key=self.config["google_api_key"])
    elif not self.config["google_api_key"]:
        self.missing_apis.append("Google API Key")

def get(self, key: str, default=None):
    """Get configuration value"""
    return self.config.get(key, default)

def __getitem__(self, key: str):
    """Allow dict-like access"""
    return self.config[key]
```

# === LOGGING SYSTEM ===

def setup_logging(log_file_path: str):
â€œâ€â€œSetup comprehensive logging systemâ€â€â€
os.makedirs(os.path.dirname(log_file_path), exist_ok=True)

```
formatter = logging.Formatter(
    '%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s'
)

# File handler
file_handler = logging.FileHandler(log_file_path)
file_handler.setFormatter(formatter)

# Console handler
console_handler = logging.StreamHandler()
console_handler.setFormatter(formatter)

# Configure root logger
root_logger = logging.getLogger()
root_logger.setLevel(logging.INFO)
root_logger.addHandler(file_handler)
root_logger.addHandler(console_handler)

# Reduce third-party noise
logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('PIL').setLevel(logging.WARNING)
logging.getLogger('moviepy').setLevel(logging.WARNING)

logging.info("AutoMagic logging system initialized")
```

# === TREND ANALYSIS SYSTEM ===

class TrendAnalyzer:
â€œâ€â€œAnalyzes current trends across social media platformsâ€â€â€

```
def __init__(self, config: AutoMagicConfig):
    self.config = config
    self.session = requests.Session()
    self.session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    })

def get_trending_data(self) -> Tuple[Optional[str], List[str], str]:
    """Get trending sounds, hashtags, and visual styles"""
    logging.info("Analyzing current trends...")
    
    trending_hashtags = self._get_trending_hashtags()
    trending_sounds = self._get_trending_sounds()
    visual_style = self._select_visual_style()
    
    return trending_sounds, trending_hashtags, visual_style

def _get_trending_hashtags(self) -> List[str]:
    """Get trending hashtags from various sources"""
    try:
        # Try to scrape trending hashtags (simplified approach)
        if HAS_BS4:
            # This is a placeholder - real implementation would use actual APIs
            # or more sophisticated scraping
            pass
    except Exception as e:
        logging.error(f"Error fetching trending hashtags: {e}")
    
    # Fallback to curated trending hashtags
    base_hashtags = [
        "#AI", "#Surreal", "#Glitchcore", "#Weirdcore", "#Liminal",
        "#Affirmation", "#AIart", "#DigitalArt", "#MindBending", 
        "#Vaporwave", "#Y2K", "#Cyberpunk", "#Dreamcore"
    ]
    
    # Add some dynamic elements based on current events
    current_month = datetime.now().strftime("%B").lower()
    seasonal_tags = {
        "january": ["#NewYear", "#Fresh", "#Resolution"],
        "february": ["#Love", "#Hearts", "#Valentine"],
        "march": ["#Spring", "#Renewal", "#Growth"],
        "april": ["#Bloom", "#Easter", "#Rebirth"],
        "may": ["#Flowers", "#Mother", "#Cinco"],
        "june": ["#Summer", "#Pride", "#Graduate"],
        "july": ["#Freedom", "#America", "#Independence"],
        "august": ["#Hot", "#Vacation", "#Summer"],
        "september": ["#BackToSchool", "#Autumn", "#Harvest"],
        "october": ["#Halloween", "#Spooky", "#Orange"],
        "november": ["#Thanksgiving", "#Gratitude", "#Fall"],
        "december": ["#Christmas", "#Holiday", "#Winter"]
    }
    
    if current_month in seasonal_tags:
        base_hashtags.extend(seasonal_tags[current_month])
    
    return base_hashtags[:10]  # Return top 10

def _get_trending_sounds(self) -> Optional[str]:
    """Get or select trending background music"""
    sound_library = "assets/sounds/"
    
    # Check for existing sound files
    if os.path.exists(sound_library):
        sound_files = [f for f in os.listdir(sound_library) 
                      if f.endswith(('.mp3', '.wav', '.m4a'))]
        if sound_files:
            selected = random.choice(sound_files)
            return os.path.join(sound_library, selected)
    
    # Create a simple procedural sound if none available
    return None

def _select_visual_style(self) -> str:
    """Select current trending visual style"""
    styles = [
        "glitchcore", "vaporwave", "weirdcore", "liminal", 
        "cyberpunk", "y2k", "dreamcore", "synthwave"
    ]
    
    # Weight selection based on current season/trends
    current_style = self.config.get("content_style", "glitchcore")
    
    if current_style in styles:
        return current_style
    
    return random.choice(styles)
```

# === CONTENT GENERATION SYSTEM ===

class ContentGenerator:
â€œâ€â€œHandles all AI-powered content generationâ€â€â€

```
def __init__(self, config: AutoMagicConfig):
    self.config = config

def generate_affirmation_text(self, theme: str, style: str = "surreal") -> str:
    """Generate surreal affirmation text using available LLMs"""
    logging.info(f"Generating affirmation text for theme: {theme}")
    
    prompt = f"""
    Create a surreal, mind-bending affirmation about {theme}.
    Style: Raw, gritty, humorous, potentially unsettling.
    Length: 1-2 sentences maximum.
    Make it memorable and thought-provoking.
    
    Examples of the style:
    - "Your reality is just a suggestion. Ignore it when convenient."
    - "The void stares back. Offer it a sandwich."
    - "You are the cosmic background radiation wearing human clothes."
    
    Generate one unique affirmation:
    """
    
    # Try Gemini first
    if HAS_GEMINI and self.config["google_api_key"]:
        try:
            model = genai.GenerativeModel('gemini-pro')
            response = model.generate_content(prompt)
            if hasattr(response, 'text') and response.text:
                return response.text.strip()
        except Exception as e:
            logging.error(f"Gemini text generation failed: {e}")
    
    # Fallback to OpenAI
    if HAS_OPENAI and self.config["openai_api_key"]:
        try:
            client = openai.OpenAI(api_key=self.config["openai_api_key"])
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=100,
                temperature=0.9
            )
            if response.choices and response.choices[0].message.content:
                return response.choices[0].message.content.strip()
        except Exception as e:
            logging.error(f"OpenAI text generation failed: {e}")
    
    # Ultimate fallback
    fallback_affirmations = [
        "Reality is optional. Terms and conditions may apply.",
        "Your consciousness is just visiting this dimension. Be a good tourist.",
        "The universe runs on sarcasm and expired coupons.",
        "Time is an illusion. Lunchtime doubly so.",
        "You are not your thoughts. You are the commercial breaks between them."
    ]
    
    return random.choice(fallback_affirmations)

def generate_tts_audio(self, text: str, output_path: str) -> Optional[str]:
    """Generate text-to-speech audio"""
    logging.info(f"Generating TTS for: {text[:50]}...")
    
    if not text:
        logging.error("No text provided for TTS")
        return None
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"tts_{timestamp}.mp3"
    full_path = os.path.join(output_path, filename)
    
    # Try ElevenLabs
    if HAS_ELEVENLABS and self.config["elevenlabs_api_key"]:
        try:
            voice_id = self.config["elevenlabs_voice_id"] or "premade/Adam"
            audio = elevenlabs.generate(
                text=text,
                voice=voice_id,
                model="eleven_turbo_v2"
            )
            elevenlabs.save(audio, full_path)
            
            if os.path.exists(full_path) and os.path.getsize(full_path) > 0:
                logging.info(f"TTS audio saved to {full_path}")
                return full_path
        except Exception as e:
            logging.error(f"ElevenLabs TTS failed: {e}")
    
    # Create placeholder audio file
    try:
        # Create a minimal valid audio file placeholder
        with open(full_path, 'wb') as f:
            # Write minimal MP3 header
            f.write(b'\xFF\xFB\x90\x44' + b'\x00' * 1024)
        logging.info(f"Placeholder audio created at {full_path}")
        return full_path
    except Exception as e:
        logging.error(f"Failed to create placeholder audio: {e}")
        return None

def generate_image(self, prompt: str, output_path: str) -> Optional[str]:
    """Generate image using DALL-E or ComfyUI"""
    logging.info(f"Generating image for: {prompt[:50]}...")
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"image_{timestamp}.png"
    full_path = os.path.join(output_path, filename)
    
    # Try DALL-E first
    if HAS_OPENAI and self.config["openai_api_key"]:
        try:
            client = openai.OpenAI(api_key=self.config["openai_api_key"])
            response = client.images.generate(
                model="dall-e-3",
                prompt=prompt,
                size="1024x1024",
                quality="standard",
                n=1,
            )
            
            image_url = response.data[0].url
            img_response = requests.get(image_url, timeout=30)
            img_response.raise_for_status()
            
            with open(full_path, 'wb') as f:
                f.write(img_response.content)
            
            if os.path.exists(full_path) and os.path.getsize(full_path) > 0:
                logging.info(f"DALL-E image saved to {full_path}")
                return full_path
        except Exception as e:
            logging.error(f"DALL-E generation failed: {e}")
    
    # Try ComfyUI fallback
    comfyui_result = self._try_comfyui_generation(prompt, full_path)
    if comfyui_result:
        return comfyui_result
    
    # Create procedural placeholder image
    return self._create_placeholder_image(prompt, full_path)

def _try_comfyui_generation(self, prompt: str, output_path: str) -> Optional[str]:
    """Try ComfyUI generation if available"""
    if not self.config["comfyui_api_address"]:
        return None
    
    try:
        # Check if ComfyUI server is available
        response = requests.get(f"{self.config['comfyui_api_address']}/system_stats", timeout=5)
        if response.status_code == 200:
            # ComfyUI integration would go here
            # For now, return None to fall back to placeholder
            pass
    except Exception as e:
        logging.warning(f"ComfyUI not available: {e}")
    
    return None

def _create_placeholder_image(self, prompt: str, output_path: str) -> str:
    """Create a procedural placeholder image"""
    try:
        # Create unique image based on prompt hash
        prompt_hash = hashlib.md5(prompt.encode()).hexdigest()
        
        # Generate base colors from hash
        r1 = int(prompt_hash[:2], 16)
        g1 = int(prompt_hash[2:4], 16)
        b1 = int(prompt_hash[4:6], 16)
        r2 = int(prompt_hash[6:8], 16)
        g2 = int(prompt_hash[8:10], 16)
        b2 = int(prompt_hash[10:12], 16)
        
        # Create gradient image
        width, height = 1024, 1024
        image = Image.new('RGB', (width, height))
        
        for y in range(height):
            for x in range(width):
                # Create gradient effect
                ratio_x = x / width
                ratio_y = y / height
                
                r = int(r1 * (1 - ratio_x) + r2 * ratio_x)
                g = int(g1 * (1 - ratio_y) + g2 * ratio_y)
                b = int(b1 * (1 - ratio_x * ratio_y) + b2 * (ratio_x * ratio_y))
                
                image.putpixel((x, y), (r % 256, g % 256, b % 256))
        
        # Add some noise/texture
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(1.2)
        
        # Save image
        image.save(output_path)
        logging.info(f"Placeholder image created at {output_path}")
        return output_path
        
    except Exception as e:
        logging.error(f"Failed to create placeholder image: {e}")
        return None
```

# === VIDEO PROCESSING SYSTEM ===

class VideoProcessor:
â€œâ€â€œHandles video generation and processingâ€â€â€

```
def __init__(self, config: AutoMagicConfig):
    self.config = config

def create_video_from_image(self, image_path: str, duration: float = 8.0) -> Optional[str]:
    """Create animated video from static image"""
    if not HAS_MOVIEPY:
        logging.error("MoviePy not available - cannot create video")
        return None
    
    if not os.path.exists(image_path):
        logging.error(f"Image not found: {image_path}")
        return None
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    output_path = os.path.join(
        self.config["video_clip_save_path"], 
        f"animated_{timestamp}.mp4"
    )
    
    try:
        # Create base clip from image
        clip = ImageClip(image_path, duration=duration)
        
        # Apply animations based on style
        style = self.config.get("content_style", "glitchcore")
        clip = self._apply_style_effects(clip, style)
        
        # Write video
        clip.write_videofile(
            output_path,
            fps=24,
            codec='libx264',
            audio=False,
            logger=None
        )
        
        clip.close()
        logging.info(f"Animated video created: {output_path}")
        return output_path
        
    except Exception as e:
        logging.error(f"Failed to create video from image: {e}")
        return None

def _apply_style_effects(self, clip, style: str):
    """Apply visual effects based on style"""
    if style == "glitchcore":
        # Add glitch effect
        def glitch_effect(get_frame, t):
            frame = get_frame(t)
            if random.random() < 0.1:  # 10% chance of glitch per frame
                # RGB channel shift
                if len(frame.shape) == 3:
                    shift = random.randint(-10, 10)
                    if shift != 0:
                        frame[:, :, 0] = np.roll(frame[:, :, 0], shift, axis=1)
            return frame
        
        clip = clip.fl(glitch_effect)
        
    elif style == "vaporwave":
        # Color enhancement for vaporwave
        clip = clip.fx(vfx.colorx, 1.2)  # Increase saturation
        
    elif style == "cyberpunk":
        # High contrast effect
        clip = clip.fx(vfx.colorx, 1.3)
    
    # Add zoom effect
    zoom_factor = 1.1
    clip = clip.fx(vfx.resize, lambda t: 1 + (zoom_factor - 1) * t / clip.duration)
    
    return clip

def assemble_final_video(
    self, 
    video_clips: List[str], 
    audio_path: Optional[str],
    text_overlay: str,
    background_music: Optional[str],
    output_path: str
) -> Optional[str]:
    """Assemble final video from components"""
    if not HAS_MOVIEPY:
        logging.error("MoviePy not available - cannot assemble video")
        return None
    
    logging.info("Assembling final video...")
    
    try:
        clips = []
        
        # Load video clips
        for clip_path in video_clips:
            if clip_path and os.path.exists(clip_path):
                try:
                    clip = VideoFileClip(clip_path)
                    clips.append(clip)
                except Exception as e:
                    logging.error(f"Failed to load clip {clip_path}: {e}")
        
        if not clips:
            logging.error("No valid video clips to assemble")
            return None
        
        # Concatenate clips
        if len(clips) > 1:
            final_clip = concatenate_videoclips(clips)
        else:
            final_clip = clips[0]
        
        # Add text overlay
        if text_overlay:
            text_clip = self._create_text_overlay(text_overlay, final_clip.size, final_clip.duration)
            if text_clip:
                final_clip = CompositeVideoClip([final_clip, text_clip])
        
        # Add audio
        audio_clips = []
        
        # Add voiceover
        if audio_path and os.path.exists(audio_path):
            try:
                voiceover = AudioFileClip(audio_path)
                if voiceover.duration > final_clip.duration:
                    voiceover = voiceover.subclip(0, final_clip.duration)
                audio_clips.append(voiceover)
            except Exception as e:
                logging.error(f"Failed to load audio {audio_path}: {e}")
        
        # Add background music
        if background_music and os.path.exists(background_music):
            try:
                bg_music = AudioFileClip(background_music).volumex(0.3)
                if bg_music.duration > final_clip.duration:
                    bg_music = bg_music.subclip(0, final_clip.duration)
                audio_clips.append(bg_music)
            except Exception as e:
                logging.error(f"Failed to load background music {background_music}: {e}")
        
        # Compose audio
        if audio_clips:
            if len(audio_clips) > 1:
                final_audio = CompositeAudioClip(audio_clips)
            else:
                final_audio = audio_clips[0]
            final_clip = final_clip.set_audio(final_audio)
        
        # Limit duration for social media
        max_duration = self.config.get("max_video_duration", 60)
        if final_clip.duration > max_duration:
            final_clip = final_clip.subclip(0, max_duration)
        
        # Write final video
        final_clip.write_videofile(
            output_path,
            fps=24,
            codec='libx264',
            audio_codec='aac',
            bitrate='5000k',
            logger=None
        )
        
        # Cleanup
        for clip in clips:
            clip.close()
        for audio in audio_clips:
            audio.close()
        final_clip.close()
        
        if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
            logging.info(f"Final video assembled: {output_path}")
            return output_path
        else:
            logging.error("Final video file is empty or missing")
            return None
            
    except Exception as e:
        logging.error(f"Failed to assemble video: {e}")
        return None

def _create_text_overlay(self, text: str, video_size: Tuple[int, int], duration: float):
    """Create text overlay for video"""
    if not HAS_MOVIEPY:
        return None
    
    try:
        # Break text into lines
        words = text.split()
        lines = []
        current_line = []
        
        for word in words:
            if len(' '.join(current_line + [word])) > 30:
                if current_line:
                    lines.append(' '.join(current_line))
                    current_line = [word]
                else:
                    lines.append(word)
            else:
                current_line.append(word)
        
        if current_line:
            lines.append(' '.join(current_line))
        
        formatted_text = '\n'.join(lines)
        
        # Create text clip
        txt_clip = TextClip(
            formatted_text,
            fontsize=min(video_size) // 25,
            color='white',
            stroke_color='black',
            stroke_width=2,
            method='caption',
            align='center'
        ).set_position('center').set_duration(duration)
        
        # Add fade effects
        txt_clip = txt_clip.fadein(0.5).fadeout(0.5)
        
        return txt_clip
        
    except Exception as e:
        logging.error(f"Failed to create text overlay: {e}")
        return None
```

# === SOCIAL MEDIA INTEGRATION ===

class SocialMediaManager:
â€œâ€â€œHandles uploading to social media platformsâ€â€â€

```
def __init__(self, config: AutoMagicConfig):
    self.config = config

def generate_metadata(self, theme: str, trending_hashtags: List[str]) -> Dict[str, Any]:
    """Generate optimized metadata for platforms"""
    logging.info("Generating social media metadata...")
    
    # Use AI to generate if available, otherwise use templates
    try:
        prompt = f"""
        Create engaging social media metadata for a surreal AI-generated video about: {theme}
        
        Provide:
        1. YouTube title (under 100 chars, attention-grabbing)
        2. YouTube description (2-3 sentences + call to action)  
        3. YouTube tags (10 relevant tags)
        4. TikTok caption (under 150 chars, mysterious/intriguing)
        5. TikTok hashtags (5-8 including: {' '.join(trending_hashtags[:3])})
        
        Format as JSON with keys: youtube_title, youtube_description, youtube_tags, tiktok_caption, tiktok_hashtags
        """
        
        # Try to get AI-generated metadata
        if HAS_GEMINI and self.config["google_api_key"]:
            try:
                model = genai.GenerativeModel('gemini-pro')
                response = model.generate_content(prompt)
                if hasattr(response, 'text'):
                    # Simple parsing - in production would use more robust JSON parsing
                    metadata_text = response.text
                    # For now, use fallback
            except Exception as e:
                logging.error(f"AI metadata generation failed: {e}")
    except Exception as e:
        logging.error(f"Metadata generation error: {e}")
    
    # Fallback to template-based metadata
    today = datetime.now().strftime('%Y-%m-%d')
    
    return {
        'youtube_title': f"Surreal AI Wisdom: {theme} | Mind-Bending Daily Affirmation",
        'youtube_description': f"Experience a mind-bending AI-generated affirmation about {theme}. These surreal daily doses of wisdom will make you question reality itself. Subscribe for daily cosmic insights! #AI #Surreal #Wisdom",
        'youtube_tags': ['AI', 'Surreal', 'Affirmation', 'Digital Art', 'Philosophy', 'Mind-Bending', 'Daily Wisdom', 'Artificial Intelligence', 'Short Video', 'Viral Content'],
        'tiktok_caption': f"When AI gets philosophical about {theme.lower()}... ğŸ¤–âœ¨",
        'tiktok_hashtags': ' '.join(trending_hashtags[:8])
    }

def upload_to_youtube(self, video_path: str, metadata: Dict[str, Any]) -> bool:
    """Upload video to YouTube"""
    if not HAS_GOOGLE_APIS:
        logging.error("Google APIs not available - YouTube upload disabled")
        return False
    
    logging.info(f"Uploading to YouTube: {metadata['youtube_title']}")
    
    try:
        youtube_service = self._get_youtube_service()
        if not youtube_service:
            return False
        
        body = {
            'snippet': {
                'title': metadata['youtube_title'],
                'description': metadata['youtube_description'],
                'tags': metadata['youtube_tags'],
                'categoryId': '22'  # People & Blogs
            },
            'status': {
                'privacyStatus': 'public',
                'selfDeclaredMadeForKids': False
            }
        }
        
        media = MediaFileUpload(video_path, mimetype='video/mp4', resumable=True)
        
        request = youtube_service.videos().insert(
            part=','.join(body.keys()),
            body=body,
            media_body=media
        )
        
        response = None
        while response is None:
            status, response = request.next_chunk()
            if status:
                logging.info(f"YouTube upload progress: {int(status.progress() * 100)}%")
        
        video_id = response.get('id')
        if video_id:
            logging.info(f"YouTube upload successful! Video ID: {video_id}")
            return True
        else:
            logging.error("YouTube upload failed - no video ID returned")
            return False
            
    except Exception as e:
        logging.error(f"YouTube upload failed: {e}")
        return False

def _get_youtube_service(self):
    """Get authenticated YouTube service"""
    CLIENT_SECRETS_FILE = "client_secret.json"
    SCOPES = ['https://www.googleapis.com/auth/youtube.upload']
    CREDENTIALS_FILE = "youtube_credentials.json"
    
    creds = None
    
    # Load existing credentials
    if os.path.exists(CREDENTIALS_FILE):
        try:
            creds = Credentials.from_authorized_user_file(CREDENTIALS_FILE, SCOPES)
        except Exception as e:
            logging.error(f"Error loading credentials: {e}")
    
    # Refresh or create credentials
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
                with open(CREDENTIALS_FILE, 'w') as token:
                    token.write(creds.to_json())
            except Exception as e:
                logging.error(f"Error refreshing credentials: {e}")
                creds = None
        
        if not creds:
            if not os.path.exists(CLIENT_SECRETS_FILE):
                logging.error(f"Missing {CLIENT_SECRETS_FILE} - download from Google Cloud Console")
                return None
            
            try:
                flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRETS_FILE, SCOPES)
                creds = flow.run_local_server(port=0)
                with open(CREDENTIALS_FILE, 'w') as token:
                    token.write(creds.to_json())
            except Exception as e:
                logging.error(f"OAuth flow failed: {e}")
                return None
    
    try:
        return build('youtube', 'v3', credentials=creds)
    except Exception as e:
        logging.error(f"Failed to build YouTube service: {e}")
        return None

def upload_to_tiktok(self, video_path: str, metadata: Dict[str, Any]) -> bool:
    """Upload video to TikTok (placeholder implementation)"""
    logging.warning("TikTok upload not implemented - would require unofficial methods")
    return False
```

# === MAIN AUTOMATION SYSTEM ===

class AutoMagicOrchestrator:
â€œâ€â€œMain orchestration system for AutoMagicâ€â€â€

```
def __init__(self):
    self.config = AutoMagicConfig()
    self.trend_analyzer = TrendAnalyzer(self.config)
    self.content_generator = ContentGenerator(self.config)
    self.video_processor = VideoProcessor(self.config)
    self.social_media = SocialMediaManager(self.config)
    
    # Report missing APIs
    if self.config.missing_apis:
        logging.warning(f"Missing APIs: {', '.join(self.config.missing_apis)}")

def run_daily_job(self) -> bool:
    """Execute the complete daily automation workflow"""
    logging.info("ğŸš€ Starting AutoMagic daily job...")
    
    try:
        # 1. Analyze trends
        trending_sound, trending_hashtags, visual_style = self.trend_analyzer.get_trending_data()
        logging.info(f"Trending style: {visual_style}, hashtags: {len(trending_hashtags)}")
        
        # 2. Generate content theme
        season = self.config["season"]
        day = self.config["day_number"]
        theme = self.config["content_themes"].get(season, "Unknown Reality")
        content_theme = f"Season {season} Day {day}: {theme}"
        
        # 3. Generate affirmation text
        affirmation = self.content_generator.generate_affirmation_text(content_theme, visual_style)
        logging.info(f"Generated affirmation: {affirmation}")
        
        # 4. Generate audio
        audio_path = self.content_generator.generate_tts_audio(
            affirmation, 
            self.config["audio_save_path"]
        )
        
        # 5. Generate image
        image_prompt = f"Surreal, {visual_style} style artwork representing: {affirmation}. Highly detailed, mind-bending, artistic."
        image_path = self.content_generator.generate_image(
            image_prompt,
            self.config["image_save_path"]
        )
        
        if not image_path:
            logging.error("Failed to generate image - aborting")
            return False
        
        # 6. Create video from image
        video_path = self.video_processor.create_video_from_image(image_path)
        if not video_path:
            logging.error("Failed to create video - aborting")
            return False
        
        # 7. Assemble final video
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        final_video_path = os.path.join(
            self.config["final_video_save_path"],
            f"AutoMagic_{timestamp}.mp4"
        )
        
        final_video = self.video_processor.assemble_final_video(
            video_clips=[video_path],
            audio_path=audio_path,
            text_overlay=affirmation,
            background_music=trending_sound,
            output_path=final_video_path
        )
        
        if not final_video:
            logging.error("Failed to assemble final video - aborting")
            return False
        
        # 8. Generate metadata
        metadata = self.social_media.generate_metadata(content_theme, trending_hashtags)
        
        # 9. Upload to platforms
        youtube_success = self.social_media.upload_to_youtube(final_video, metadata)
        tiktok_success = self.social_media.upload_to_tiktok(final_video, metadata)
        
        # 10. Cleanup if configured
        if self.config["cleanup_temp_files"]:
            self._cleanup_temp_files([audio_path, image_path, video_path])
        
        # 11. Update counters
        self._update_progress()
        
        success = youtube_success or tiktok_success
        logging.info(f"âœ… Daily job completed! Success: {success}")
        return success
        
    except Exception as e:
        logging.error(f"âŒ Daily job failed: {e}")
        return False

def _cleanup_temp_files(self, file_paths: List[Optional[str]]):
    """Clean up temporary files"""
    for path in file_paths:
        if path and os.path.exists(path):
            try:
                os.remove(path)
                logging.info(f"Cleaned up: {path}")
            except Exception as e:
                logging.error(f"Failed to cleanup {path}: {e}")

def _update_progress(self):
    """Update day/season progress"""
    try:
        state_file = "project_state.json"
        
        # Load current state
        if os.path.exists(state_file):
            with open(state_file, 'r') as f:
                state = json.load(f)
        else:
            state = {
                "season": self.config["season"],
                "day_number": self.config["day_number"],
                "completed_videos": [],
                "last_run": None
            }
        
        # Update state
        state["day_number"] += 1
        state["last_run"] = datetime.now().isoformat()
        state["completed_videos"].append(datetime.now().isoformat())
        
        # Check if season is complete (arbitrary 33 days per season)
        if state["day_number"] > 33:
            state["day_number"] = 1
            state["season"] += 1
            logging.info(f"ğŸ¬ Season {state['season']} complete! Starting Season {state['season']}")
        
        # Save state
        with open(state_file, 'w') as f:
            json.dump(state, f, indent=2)
            
        logging.info(f"Progress: Season {state['season']}, Day {state['day_number']}")
        
    except Exception as e:
        logging.error(f"Failed to update progress: {e}")
```

# === COMMAND LINE INTERFACE ===

def main():
â€œâ€â€œMain entry pointâ€â€â€
parser = argparse.ArgumentParser(description=â€œAutoMagic (O.T.T.O.) - AI Content Creation Systemâ€)
parser.add_argument(â€™â€“run-onceâ€™, action=â€˜store_trueâ€™, help=â€˜Run job once and exitâ€™)
parser.add_argument(â€™â€“scheduleâ€™, action=â€˜store_trueâ€™, help=â€˜Run scheduler (default)â€™)
parser.add_argument(â€™â€“test-configâ€™, action=â€˜store_trueâ€™, help=â€˜Test configurationâ€™)

```
args = parser.parse_args()

# Initialize system
try:
    orchestrator = AutoMagicOrchestrator()
    setup_logging(orchestrator.config["log_file_path"])
    
    logging.info("ğŸ¤– AutoMagic (O.T.T.O.) System Initialized")
    logging.info(f"Configuration: {len(orchestrator.config.missing_apis)} missing APIs")
    
except Exception as e:
    print(f"âŒ Failed to initialize AutoMagic: {e}")
    sys.exit(1)

# Handle commands
if args.test_config:
    print("ğŸ” Testing configuration...")
    print(f"âœ… APIs available: {len([k for k in orchestrator.config.config.keys() if 'api_key' in k and orchestrator.config.config[k]])}")
    print(f"âš ï¸  APIs missing: {len(orchestrator.config.missing_apis)}")
    if orchestrator.config.missing_apis:
        print(f"Missing: {', '.join(orchestrator.config.missing_apis)}")
    return

if args.run_once:
    logging.info("ğŸ¬ Running single automation cycle...")
    success = orchestrator.run_daily_job()
    sys.exit(0 if success else 1)

# Default: Run scheduler
logging.info(f"â° Scheduling daily job for {orchestrator.config['daily_run_time']}")

schedule.every().day.at(orchestrator.config["daily_run_time"]).do(
    orchestrator.run_daily_job
)

logging.info("ğŸ”„ Scheduler started - press Ctrl+C to stop")

try:
    while True:
        schedule.run_pending()
        time.sleep(60)
except KeyboardInterrupt:
    logging.info("ğŸ‘‹ AutoMagic scheduler stopped")
```

if **name** == â€œ**main**â€:
main()